/**
 * !!! NOTE !!!
 *
 * If you're setting up the bot, DO NOT EDIT THIS FILE DIRECTLY!
 *
 * Create a configuration file in the same directory as the example file.
 * You never need to edit anything under src/ to use the bot.
 *
 * !!! NOTE !!!
 */

const fs = require('fs');
const path = require('path');

let userConfig;

// Config files to search for, in priority order
const configFiles = [
  'config.ini',
  'config.ini.ini',
  'config.ini.txt',
  'config.json',
  'config.json5',
  'config.json.json',
  'config.json.txt',
  'config.js'
];

let foundConfigFile;
for (const configFile of configFiles) {
  try {
    fs.accessSync(__dirname + '/../' + configFile);
    foundConfigFile = configFile;
    break;
  } catch (e) {}
}

// Load config file
if (foundConfigFile) {
  console.log(`Loading configuration from ${foundConfigFile}...`);
  try {
    if (foundConfigFile.endsWith('.js')) {
      userConfig = require(`../${foundConfigFile}`);
    } else {
      const raw = fs.readFileSync(__dirname + '/../' + foundConfigFile, {encoding: "utf8"});
      if (foundConfigFile.endsWith('.ini') || foundConfigFile.endsWith('.ini.txt')) {
        userConfig = require('ini').decode(raw);
      } else {
        userConfig = require('json5').parse(raw);
      }
    }
  } catch (e) {
    throw new Error(`Error reading config file! The error given was: ${e.message}`);
  }
}

const required = ['token', 'mailGuildId', 'mainGuildId', 'logChannelId'];
const numericOptions = ['requiredAccountAge', 'requiredTimeOnServer', 'smallAttachmentLimit', 'port'];

const defaultConfig = {
  "token": null,
  "mailGuildId": null,
  "mainGuildId": null,
  "logChannelId": null,

  "prefix": "!",
  "snippetPrefix": "!!",
  "snippetPrefixAnon": "!!!",

  "openStatus": "DM for coaching",
  "closedStatus": "Coaching currently closed",
  "responseMessage": "Thank you for your message! Our mod team will reply to you here as soon as possible.",
  "closeMessage": null,
  "allowUserClose": false,

  "gatherChoiceMessage": "Welcome to the /r/Overwatch CoachMail bot. This bot is intended for use by players who already have videos " +
  "or replays available to review with a coach, and who are looking for an interactive session analysing those videos or replays. " +
  "If you simply have questions about heroes, maps, any other aspect of the game, check out our GAMEPLAY_ADVICE channel, where " +
  "coaches and community members can help you out in a more casual format. If this applies to you, choose ❌ below to cancel the session. " +
  "I'm going to ask you a few questions so that the right kind of " +
  "coach can help you. Answer the first three questions by reacting to the appropriate emoji underneath. At any time during these questions, " +
  "react to the ❌ on this message to cancel the session.",
  "gatherRankMessage": "What's your **rank**? Select <:Unranked:705979240952365127> if you do not have a rank.",
  "gatherPlatformMessage": "What **platform** do you play on?",
  "gatherRequestMessage": "Please outline what you're looking to get from this coaching session. Be as detailed as possible, and don't " +
  "be afraid to submit a long answer. The more information you supply up front about your goals, the quicker the coaches will be able " +
  "to get to the actual coaching. Try to identify some specific mechanical or tactical issues that you think are holding you back, " +
  "such as accuracy with Pharah's rockets or determining the best times and teammates to use Zarya's barriers with.",
  "gatherReplayMessage": "Please share a replay code, or a link to a video of your gameplay that you want to review with a coach. " +
  "If you're not sure how to get replay codes, please visit " +
  "https://playoverwatch.com/en-us/news/23000187/introducing-overwatch-replays-see-your-past-games-from-new-perspectives",
  "gatherIncompleteMessage": "You didn't respond to all the questions. Make a selection for each, and then react to ✅ on this message.",
  "gatherCompleteMessage": "Great! Your info has been sent to the coaches. Whoever's best matched with your situation will respond to you " +
  "as soon as they can. In the meantime, anything you send me from now on will be shared directly with the coaches. So, if you have " +
  "things like links to videos you would like reviewed, you can send them right away.",
  "userCanCloseMessage": "You can choose to end the session early at any time by typing `!close` in this window.",
  "gatherCancelmessage": "OK. Cancelling this coaching session. Start another at any time by messaging me again!",
  "gatherTimeoutMessage": "Your session has timed out because you didn't answer the initial questions. You can start another at any time " +
  "by messaging me again.",
  "gatherTimeout": null, // minutes
  "apologyMessage": null,
  "apologyTimeout": null, // minutes
  "platformChoiceReactions": [],
  "rankChoiceReactions": [],
  "roleChoiceReactions": [],
  "coachInfoChannel": null,
  "adviceChannel": null,
  "overrideCoachingClosed": null,

  "newThreadCategoryId": null,
  "mentionRole": "here",
  "pingOnBotMention": true,
  "botMentionResponse": null,

  "inboxServerPermission": null,
  "alwaysReply": false,
  "alwaysReplyAnon": false,
  "useNicknames": false,
  "ignoreAccidentalThreads": false,
  "threadTimestamps": false,
  "allowMove": false,
  "syncPermissionsOnMove": true,
  "typingProxy": false,
  "typingProxyReverse": false,
  "mentionUserInThreadHeader": false,
  "rolesInThreadHeader": false,

  "enableGreeting": false,
  "greetingMessage": null,
  "greetingAttachment": null,

  "guildGreetings": {},

  "requiredAccountAge": null, // In hours
  "accountAgeDeniedMessage": "Your Discord account is not old enough to contact CoachMail.",

  "requiredTimeOnServer": null, // In minutes
  "timeOnServerDeniedMessage": "You haven't been a member of the server for long enough to contact CoachMail.",

  "relaySmallAttachmentsAsAttachments": false,
  "smallAttachmentLimit": 1024 * 1024 * 2,
  "attachmentStorage": "local",
  "attachmentStorageChannelId": null,

  "categoryAutomation": {},

  "updateNotifications": true,
  "plugins": [],

  "commandAliases": {},

  "port": 8890,
  "url": null,

  "dbDir": path.join(__dirname, '..', 'db'),
  "knex": null,

  "logDir": path.join(__dirname, '..', 'logs'),
};

// Load config values from environment variables
const envKeyPrefix = 'MM_';
let loadedEnvValues = 0;

for (const [key, value] of Object.entries(process.env)) {
  if (! key.startsWith(envKeyPrefix)) continue;

  // MM_CLOSE_MESSAGE -> closeMessage
  // MM_COMMAND_ALIASES__MV => commandAliases.mv
  const configKey = key.slice(envKeyPrefix.length)
    .toLowerCase()
    .replace(/([a-z])_([a-z])/g, (m, m1, m2) => `${m1}${m2.toUpperCase()}`)
    .replace('__', '.');

  userConfig[configKey] = value.includes('||')
    ? value.split('||')
    : value;

  loadedEnvValues++;
}

if (process.env.PORT && !process.env.MM_PORT) {
  // Special case: allow common "PORT" environment variable without prefix
  userConfig.port = process.env.PORT;
  loadedEnvValues++;
}

if (loadedEnvValues > 0) {
  console.log(`Loaded ${loadedEnvValues} ${loadedEnvValues === 1 ? 'value' : 'values'} from environment variables`);
}

// Convert config keys with periods to objects
// E.g. commandAliases.mv -> commandAliases: { mv: ... }
for (const [key, value] of Object.entries(userConfig)) {
  if (! key.includes('.')) continue;

  const keys = key.split('.');
  let cursor = userConfig;
  for (let i = 0; i < keys.length; i++) {
    if (i === keys.length - 1) {
      cursor[keys[i]] = value;
    } else {
      cursor[keys[i]] = cursor[keys[i]] || {};
      cursor = cursor[keys[i]];
    }
  }

  delete userConfig[key];
}

// Combine user config with default config to form final config
const finalConfig = Object.assign({}, defaultConfig);

for (const [prop, value] of Object.entries(userConfig)) {
  if (! defaultConfig.hasOwnProperty(prop)) {
    throw new Error(`Unknown option: ${prop}`);
  }

  finalConfig[prop] = value;
}

// Default knex config
if (! finalConfig['knex']) {
  finalConfig['knex'] = {
    client: 'sqlite',
      connection: {
      filename: path.join(finalConfig.dbDir, 'data.sqlite')
    },
    useNullAsDefault: true
  };
}

// Make sure migration settings are always present in knex config
Object.assign(finalConfig['knex'], {
  migrations: {
    directory: path.join(finalConfig.dbDir, 'migrations')
  }
});

if (finalConfig.smallAttachmentLimit > 1024 * 1024 * 8) {
  finalConfig.smallAttachmentLimit = 1024 * 1024 * 8;
  console.warn('[WARN] smallAttachmentLimit capped at 8MB');
}

// Specific checks
if (finalConfig.attachmentStorage === 'discord' && ! finalConfig.attachmentStorageChannelId) {
  console.error('Config option \'attachmentStorageChannelId\' is required with attachment storage \'discord\'');
  process.exit(1);
}

// Make sure mainGuildId is internally always an array
if (! Array.isArray(finalConfig['mainGuildId'])) {
  finalConfig['mainGuildId'] = [finalConfig['mainGuildId']];
}

// Make sure inboxServerPermission is always an array
if (! Array.isArray(finalConfig['inboxServerPermission'])) {
  if (finalConfig['inboxServerPermission'] == null) {
    finalConfig['inboxServerPermission'] = [];
  } else {
    finalConfig['inboxServerPermission'] = [finalConfig['inboxServerPermission']];
  }
}

if (! Array.isArray(finalConfig['platformChoiceReactions'])) {
  if (finalConfig['platformChoiceReactions'] == null) {
    finalConfig['platformChoiceReactions'] = [];
  } else {
    finalConfig['platformChoiceReactions'] = [finalConfig['platformChoiceReactions']];
  }
}

// Move greetingMessage/greetingAttachment to the guildGreetings object internally
// Or, in other words, if greetingMessage and/or greetingAttachment is set, it is applied for all servers that don't
// already have something set up in guildGreetings. This retains backwards compatibility while allowing you to override
// greetings for specific servers in guildGreetings.
if (finalConfig.greetingMessage || finalConfig.greetingAttachment) {
  for (const guildId of finalConfig.mainGuildId) {
    if (finalConfig.guildGreetings[guildId]) continue;
    finalConfig.guildGreetings[guildId] = {
      message: finalConfig.greetingMessage,
      attachment: finalConfig.greetingAttachment
    };
  }
}

// Convert arrays of lines to multiline strings in greetings
for (const obj of Object.values(finalConfig.guildGreetings)) {
  if (Array.isArray(obj.message)) {
    obj.message = obj.message.join('\n');
  }
}

// newThreadCategoryId is syntactic sugar for categoryAutomation.newThread
if (finalConfig.newThreadCategoryId) {
  finalConfig.categoryAutomation.newThread = finalConfig.newThreadCategoryId;
  delete finalConfig.newThreadCategoryId;
}

// Turn empty string options to null (i.e. "option=" without a value in config.ini)
for (const [key, value] of Object.entries(finalConfig)) {
  if (value === '') {
    finalConfig[key] = null;
  }
}

// Cast numeric options to numbers
for (const numericOpt of numericOptions) {
  if (finalConfig[numericOpt] != null) {
    const number = parseFloat(finalConfig[numericOpt]);
    if (Number.isNaN(number)) {
      console.error(`Invalid numeric value for ${numericOpt}: ${finalConfig[numericOpt]}`);
      process.exit(1);
    }
    finalConfig[numericOpt] = number;
  }
}

// Cast boolean options (on, true, 1) (off, false, 0)
for (const [key, value] of Object.entries(finalConfig)) {
  if (typeof value !== "string") continue;
  if (["on", "true", "1"].includes(value)) {
    finalConfig[key] = true;
  } else if (["off", "false", "0"].includes(value)) {
    finalConfig[key] = false;
  }
}

// Make sure all of the required config options are present
for (const opt of required) {
  if (! finalConfig[opt]) {
    console.error(`Missing required config.json value: ${opt}`);
    process.exit(1);
  }
}

console.log("Configuration ok!");

module.exports = finalConfig;
